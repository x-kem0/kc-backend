defmodule KC.Utils.Typescript do
  @moduledoc false
  @types [
    KC.Chapter,
    KC.Page
  ]

  @api_names %{
    KC.Chapter => "chapter",
    KC.Page => "page"
  }

  @ecto_type_to_ts %{
    integer: "number",
    float: "number",
    boolean: "boolean",
    string: "string",
    bitstring: "string",
    map: "object",
    binary: "string",
    decimal: "number",
    id: "string",
    binary_id: "string",
    utc_datetime: "Date",
    naive_datetime: "Date",
    date: "Date",
    any: "any"
    # ---------- unsupported types ----------
    # time: "",
    # utc_datetime_usec: "",
    # naive_datetime_usec: "",
    # time_usec: "",
    # duration: ""
  }

  def class_name(module) do
    with :ok <- check_module(module) do
      {:ok, module |> to_string() |> String.split(".") |> List.last()}
    end
  end

  def class_name!(module) do
    {:ok, name} = class_name(module)
    name
  end

  defp check_module(module) do
    if Code.ensure_loaded?(module) do
      :ok
    else
      {:error, :invalid_module}
    end
  end

  def fields(module) do
    with :ok <- check_module(module) do
      fields = module.__schema__(:fields)
      associations = module.__schema__(:associations)
      virtual_fields = module.__schema__(:virtual_fields)

      fields =
        Enum.reduce(fields, %{}, fn field, acc ->
          type = module.__schema__(:type, field)
          type = @ecto_type_to_ts[type]
          Map.put(acc, to_string(field), type)
        end)

      fields =
        Map.put(fields, :api_name, ~s("#{@api_names[module]}"))

      associations =
        Enum.reduce(associations, %{}, fn field, acc ->
          %{
            related: type,
            cardinality: cardinality
          } =
            case module.__schema__(:association, field) do
              %Ecto.Association.HasThrough{through: through} -> get_through_module(module, through)
              f -> f
            end

          {:ok, type} = class_name(type)

          field = to_string(field)

          type =
            if cardinality == :many do
              "#{type}[]"
            else
              type
            end

          Map.put(acc, "#{field}?", type)
        end)

      virtual_fields =
        Enum.reduce(virtual_fields, %{}, fn field, acc ->
          type = module.__schema__(:virtual_type, field)
          type = @ecto_type_to_ts[type]
          field = "#{to_string(field)}?"
          Map.put(acc, field, type)
        end)

      field_lines =
        for {key, type} <- fields do
          "\t#{key}: #{type}"
        end

      virtual_lines =
        for {key, type} <- virtual_fields do
          "\t#{key}: #{type}"
        end

      assoc_lines =
        for {key, type} <- associations do
          "\t#{key}: #{type}"
        end

      lines = field_lines ++ virtual_lines ++ assoc_lines

      fields = """
      {
      #{Enum.join(lines, ",\n")}
      }
      """

      {:ok, fields}
    end
  end

  def fields!(module) do
    {:ok, fields} = fields(module)
    fields
  end

  def get_through_module(module, [field]) do
    module.__schema__(:association, field)
  end

  def get_through_module(module, [field | tail]) do
    %{
      related: next_mod
    } = module.__schema__(:association, field)

    get_through_module(next_mod, tail)
  end

  def interface(module, extends \\ "") do
    with {:ok, cls} <- class_name(module),
         {:ok, fields} <- fields(module) do
      interface = """
      declare interface #{cls}#{extends} #{fields}
      """

      {:ok, interface}
    end
  end

  def interface!(module, extends \\ "") do
    {:ok, interface} = interface(module, extends)
    interface
  end

  def full_specification! do
    interfaces =
      @types
      |> Enum.map_join("", fn module ->
        interface!(module, " extends KCAPIObject")
      end)
      |> String.trim()

    String.trim("""
    // ---------------------------------------------------------------------------
    // This file is generated by kc_core; it is not intended to be manually edited!
    // See KC.Utils.Typescript.full_specification!/1 in the backend implementation
    //
    // Generated #{DateTime.utc_now()} (UTC)
    // ---------------------------------------------------------------------------

    declare interface KCAPIObject {
    \tapi_name: string,
    \tid: string
    }

    #{interfaces}

    declare interface KCDBOperation<T extends KCAPIObject> {
    \taction: "create" | "update" | "delete",
    \tobject: string,
    \tdata: Partial<T>
    }
    """)
  end

  def generate_types_file do
    File.write!("./priv/types.ts", full_specification!())
  end
end
